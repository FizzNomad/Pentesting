# SSL/TLS Ciphersuite Security Analyzer

# Import necessary libraries
import argparse
import os
import sys
import configparser
from datetime import datetime


# Define a function to identify the insecurity reasons of a ciphersuite
def get_insecurity_reason(ciphersuite):
    reasons = []

    # Identify insecure key exchange algorithms
    if "DHE_DSS" in ciphersuite or "DH_DSS" in ciphersuite:
        reasons.append("Uses weak DSS key exchange")
    elif "DH_anon" in ciphersuite:
        reasons.append("Uses anonymous Diffie-Hellman key exchange, susceptible to MITM attacks")

    # Identify insecure encryption algorithms
    if "DES" in ciphersuite or "3DES" in ciphersuite:
        reasons.append("Uses weak DES or 3DES encryption")
    elif "RC4" in ciphersuite:
        reasons.append("Uses weak RC4 encryption")
    elif "NULL" in ciphersuite:
        reasons.append("No encryption used (NULL)")

    # Identify insecure message authentication algorithms
    if "MD5" in ciphersuite:
        reasons.append("Uses weak MD5 message authentication")
    elif "SHA" in ciphersuite and "SHA256" not in ciphersuite and "SHA384" not in ciphersuite:
        reasons.append("Uses weak SHA-1 message authentication")

    # If no specific reasons were found, return a general insecurity statement
    if not reasons:
        reasons.append("Insecure due to other reasons")

    return "; ".join(reasons)

# Define a function to process the ciphersuites in a file and write the analysis results to an output file
def process_ciphersuite_file(input_file, output_file, allowed_ciphersuites=None, sort_output=False):
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(input_file, "r") as file:
        ciphersuites = file.readlines()

    # Create an empty list to hold the ciphersuite data
    ciphersuite_data = []
    
    # Loop through each ciphersuite and identify its insecurity reasons
    for ciphersuite in ciphersuites:
        # Strip any leading or trailing whitespace from the ciphersuite string
        ciphersuite = ciphersuite.strip()
        # If allowed ciphersuites are specified and this ciphersuite is not in the list, skip it
        if allowed_ciphersuites and not filter_allowed_ciphersuites(ciphersuite, allowed_ciphersuites):
            continue
        insecurity_reasons = get_insecurity_reason(ciphersuite)
        # Append a tuple of the ciphersuite and its insecurity reasons to the list of ciphersuite data
        ciphersuite_data.append((ciphersuite, insecurity_reasons))
        print(f"{ciphersuite}: {insecurity_reasons}")

    # If the sort_output flag is set, sort the list of ciphersuite data by insecurity reasons
    if sort_output:
        ciphersuite_data = sort_by_insecurity_reasons(ciphersuite_data)

    # Open the output file and write the ciphersuite data to it
    with open(output_file, "w") as file:
        for ciphersuite, insecurity_reasons in ciphersuite_data:
            file.write(f"{ciphersuite}: {insecurity_reasons}\n")

# Display instructions to the user for how to use the interactive mode
def interactive_mode():
    print("Enter 'sort' before the ciphersuite to sort the output by insecurity reasons.")
    print("Enter 'exit' to quit the interactive mode.")
    
    # Get user input for the ciphersuite to analyze or to sort the output by insecurity reasons
    while True:
        user_input = input("Enter a ciphersuite or 'sort' followed by a ciphersuite: ").strip()
        if user_input.lower() == "exit":
            break
            
        # Check if user wants to sort the output by insecurity reasons
        sort_output = False
        if user_input.lower().startswith("sort"):
            sort_output = True
            user_input = user_input[4:].strip()
            
        # Analyze the ciphersuite and print the results to the screen
        ciphersuite = user_input
        insecurity_reasons = get_insecurity_reason(ciphersuite)
        if sort_output:
            sorted_reasons = sorted(insecurity_reasons.split("; "), reverse=True)
            insecurity_reasons = "; ".join(sorted_reasons)

        print(f"{ciphersuite}: {insecurity_reasons}")

# This function filters out any ciphersuites that are not in the allowed ciphersuites list
def filter_allowed_ciphersuites(ciphersuite, allowed_ciphersuites):
    return ciphersuite in allowed_ciphersuites

# This function sorts the ciphersuite data by the number of insecurity reasons in descending order
def sort_by_insecurity_reasons(ciphersuite_data):
    return sorted(ciphersuite_data, key=lambda x: x[1], reverse=True)

def main():
    parser = argparse.ArgumentParser(description="SSL/TLS Ciphersuite Security Analyzer")
    parser.add_argument("-i", "--input", help="Input file or directory containing ciphersuites, one per line")
    parser.add_argument("-o", "--output", help="Output file or directory to write security analysis results")
    parser.add_argument("-c", "--config", help="Configuration file to customize settings")
    parser.add_argument("-s", "--sort", action="store_true", help="Sort the output by insecurity reasons")

    args = parser.parse_args()

# Check if a configuration file was passed and read it if it exists
    if args.config:
        config = configparser.ConfigParser()
        config.read(args.config)
        input_files = config.get("input", "files").split(",") if config.has_option("input", "files") else []
        output_dir = config.get("output", "directory") if config.has_option("output", "directory") else ""
    else:
        input_files = []
        output_dir = ""

# Check if an input file or directory was passed and process it accordingly
    if args.input:
        if os.path.isdir(args.input):
            input_files.extend([os.path.join(args.input, f) for f in os.listdir(args.input) if os.path.isfile(os.path.join(args.input, f))])
        else:
            input_files.append(args.input)
            
# Check if an output file or directory was passed and set the output accordingly
    if args.output:
        if os.path.isdir(args.output):
            output_dir = args.output
        else:
            output_file = args.output
    elif output_dir:
        output_file = os.path.join(output_dir, "output.txt")
    else:
        output_file = "output.txt"
        
# If input files were specified, process each file and write the output to the corresponding output file
    if input_files:
        for input_file in input_files:
            input_file = input_file.strip()
            output_file_path = os.path.join(output_dir, f"{os.path.splitext(os.path.basename(input_file))[0]}_output.txt")
            process_ciphersuite_file(input_file, output_file_path, sort_output=args.sort)
    else:
        interactive_mode()

if __name__ == "__main__":
    main()

